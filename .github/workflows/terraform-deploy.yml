name: Terraform Deploy

on:
  push:
    branches:
      - main
      - develop
      - ci/setting
    paths:
      - 'terraform/**'  # Terraform 디렉토리 변경 시에만 실행
  workflow_dispatch:

jobs:
  terraform-deploy:
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v3

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v2
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ap-northeast-2

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v2
        with:
          terraform_version: 1.0.0

      - name: Set environment based on branch
        id: set-env
        run: |
          if [[ "${{ github.ref }}" == "refs/heads/main" ]]; then
            echo "environment=release" >> $GITHUB_OUTPUT
          else
            echo "environment=dev" >> $GITHUB_OUTPUT
          fi

      # 백엔드 인프라 설정 (S3 버킷 및 DynamoDB 테이블)
      - name: Create backend infrastructure if not exists
        run: |
          # S3 버킷 존재 여부 확인
          if ! aws s3api head-bucket --bucket lovekeeper-terraform-state 2>/dev/null; then
            echo "Creating S3 bucket for Terraform state..."
            aws s3api create-bucket \
              --bucket lovekeeper-terraform-state \
              --region ap-northeast-2 \
              --create-bucket-configuration LocationConstraint=ap-northeast-2
            
            # 버전 관리 활성화
            aws s3api put-bucket-versioning \
              --bucket lovekeeper-terraform-state \
              --versioning-configuration Status=Enabled
            
            # 서버 측 암호화 활성화
            aws s3api put-bucket-encryption \
              --bucket lovekeeper-terraform-state \
              --server-side-encryption-configuration '{
                "Rules": [
                  {
                    "ApplyServerSideEncryptionByDefault": {
                      "SSEAlgorithm": "AES256"
                    }
                  }
                ]
              }'
            
            # 퍼블릭 액세스 차단
            aws s3api put-public-access-block \
              --bucket lovekeeper-terraform-state \
              --public-access-block-configuration "BlockPublicAcls=true,IgnorePublicAcls=true,BlockPublicPolicy=true,RestrictPublicBuckets=true"
          else
            echo "S3 bucket already exists."
          fi
          
          # DynamoDB 테이블 존재 여부 확인
          if ! aws dynamodb describe-table --table-name terraform-state-lock 2>/dev/null; then
            echo "Creating DynamoDB table for state locking..."
            aws dynamodb create-table \
              --table-name terraform-state-lock \
              --attribute-definitions AttributeName=LockID,AttributeType=S \
              --key-schema AttributeName=LockID,KeyType=HASH \
              --billing-mode PAY_PER_REQUEST \
              --region ap-northeast-2
          else
            echo "DynamoDB table already exists."
          fi

      # 모든 비밀을 환경 변수로 주입하는 방법 대신 tfvars 파일 생성
      - name: Create clean tfvars file
        run: |
          # 기존 파일이 있으면 삭제
          rm -f terraform/environments/${{ steps.set-env.outputs.environment }}/secrets.tfvars
          
          # 새 파일 생성 (한 번에 처리)
          cat <<EOF > terraform/environments/${{ steps.set-env.outputs.environment }}/secrets.tfvars
          db_username   = "${{ secrets.DB_USERNAME }}"
          db_password   = "${{ secrets.DB_PASSWORD }}"
          jwt_secret    = "${{ secrets.JWT_SECRET }}"
          mail_username = "${{ secrets.MAIL_USERNAME }}"
          mail_password = "${{ secrets.MAIL_PASSWORD }}"
          aws_access_key = "${{ secrets.AWS_ACCESS_KEY_ID }}"
          aws_secret_key = "${{ secrets.AWS_SECRET_ACCESS_KEY }}"
          EOF
          
          # 대안적인 방법으로 각 변수를 처리하고 싶다면:
          # touch terraform/environments/${{ steps.set-env.outputs.environment }}/secrets.tfvars
          # printf "db_username = \"%s\"\n" "${{ secrets.DB_USERNAME }}" >> terraform/environments/${{ steps.set-env.outputs.environment }}/secrets.tfvars
          # printf "db_password = \"%s\"\n" "${{ secrets.DB_PASSWORD }}" >> terraform/environments/${{ steps.set-env.outputs.environment }}/secrets.tfvars
          # ... (기타 변수들도 동일하게 처리)
          
          # 디버깅을 위해 파일이 생성되었는지 확인 (값은 숨김)
          echo "Created tfvars file with the following variables:"
          grep -o '^[^=]*' terraform/environments/${{ steps.set-env.outputs.environment }}/secrets.tfvars

      - name: Terraform Init
        working-directory: terraform/environments/${{ steps.set-env.outputs.environment }}
        run: |
          terraform init \
            -backend-config="bucket=lovekeeper-terraform-state" \
            -backend-config="key=${{ steps.set-env.outputs.environment }}/terraform.tfstate" \
            -backend-config="region=ap-northeast-2" \
            -backend-config="dynamodb_table=terraform-state-lock" \
            -backend-config="encrypt=true"

      - name: Terraform Plan
        working-directory: terraform/environments/${{ steps.set-env.outputs.environment }}
        run: terraform plan -var-file=secrets.tfvars -input=false

      # 계획 파일을 만들고 적용하는 방식으로 변경 (더 안정적)
      - name: Terraform Apply
        working-directory: terraform/environments/${{ steps.set-env.outputs.environment }}
        run: |
          terraform plan -var-file=secrets.tfvars -input=false -out=tfplan
          terraform apply -input=false -auto-approve tfplan
